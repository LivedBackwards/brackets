//

#include "fsevents_win.h"
#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#include <windows.h>

#pragma comment(lib, "node")

NodeFSEvents::NodeFSEvents(const char *szPath) : ObjectWrap(),
    m_hAsyncDir(NULL),
    m_hIoCPort(NULL),
    m_pWatchInfo(NULL),
    m_hThread(NULL)
{
    BOOL bResult = FALSE;
    if (szPath != NULL && szPath[0] != 0x00)
    {
        strncpy(m_szPathName, szPath, MAXPATH);
        m_lpBuffer = (PFILE_NOTIFY_INFORMATION)malloc(READ_DIRECTORY_CHANGES_BUFSIZE);
        if (m_lpBuffer != NULL)
        {
            m_hAsyncDir = CreateFileA(
                m_szPathName,
                FILE_LIST_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
                NULL);
            if (m_hAsyncDir != INVALID_HANDLE_VALUE)
            {
                m_hIoCPort = ::CreateIoCompletionPort(
                    m_hAsyncDir,
                    m_hIoCPort,
                    (ULONG_PTR)m_pWatchInfo,
                    0);
                if (m_hIoCPort != NULL)
                {
                	memset(&m_Overlapped, 0, sizeof(m_Overlapped));
                    uv_async_init(uv_default_loop(), &m_uvaWatcher, NodeFSEvents::Callback);
                    m_uvaWatcher.data = this;

                    // start the thread
                    DWORD dwThreadId = 0;
                    m_hThread = ::CreateThread(NULL, 0, &NodeFSEvents::Run, this, 0, &dwThreadId);

                    bResult = m_hThread != NULL;
                }
            }
        }
    }

    // if something failed, then shutdown and cleanup
    if (!bResult)
        Shutdown();
}

NodeFSEvents::~NodeFSEvents()
{
    Shutdown();
}

void NodeFSEvents::Initialize(v8::Handle<v8::Object> target) {
    HandleScope scope;
    emit_sym = NODE_PSYMBOL("emit");
    change_sym = NODE_PSYMBOL("fsevent");
    Local<FunctionTemplate> t = FunctionTemplate::New(NodeFSEvents::New);
    constructor_template = Persistent<FunctionTemplate>::New(t);
    constructor_template->InstanceTemplate()->SetInternalFieldCount(1);
    constructor_template->SetClassName(String::NewSymbol("FSEvents"));
    Local<Function> constructor = constructor_template->GetFunction();

    constructor->Set(String::New("kFSEventStreamEventFlagNone"), Integer::New(0x00000000));
    constructor->Set(String::New("kFSEventStreamEventFlagMustScanSubDirs"), Integer::New(0x00000001));
    constructor->Set(String::New("kFSEventStreamEventFlagUserDropped"), Integer::New(0x00000002));
    constructor->Set(String::New("kFSEventStreamEventFlagKernelDropped"), Integer::New(0x00000004));
    constructor->Set(String::New("kFSEventStreamEventFlagEventIdsWrapped"), Integer::New(0x00000008));
    constructor->Set(String::New("kFSEventStreamEventFlagHistoryDone"), Integer::New(0x00000010));
    constructor->Set(String::New("kFSEventStreamEventFlagRootChanged"), Integer::New(0x00000020));
    constructor->Set(String::New("kFSEventStreamEventFlagMount"), Integer::New(0x00000040));
    constructor->Set(String::New("kFSEventStreamEventFlagUnmount"), Integer::New(0x00000080));
    constructor->Set(String::New("kFSEventStreamEventFlagItemCreated"), Integer::New(0x00000100));
    constructor->Set(String::New("kFSEventStreamEventFlagItemRemoved"), Integer::New(0x00000200));
    constructor->Set(String::New("kFSEventStreamEventFlagItemInodeMetaMod"), Integer::New(0x00000400));
    constructor->Set(String::New("kFSEventStreamEventFlagItemRenamed"), Integer::New(0x00000800));
    constructor->Set(String::New("kFSEventStreamEventFlagItemModified"), Integer::New(0x00001000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemFinderInfoMod"), Integer::New(0x00002000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemChangeOwner"), Integer::New(0x00004000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemXattrMod"), Integer::New(0x00008000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemIsFile"), Integer::New(0x00010000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemIsDir"), Integer::New(0x00020000));
    constructor->Set(String::New("kFSEventStreamEventFlagItemIsSymlink"), Integer::New(0x00040000));

    target->Set(String::NewSymbol("FSEvents"), constructor);
}

v8::Handle<v8::Value> NodeFSEvents::Shutdown(const v8::Arguments& args)
{
    HandleScope scope;
    NodeFSEvents *native = node::ObjectWrap::Unwrap<NodeFSEvents>(args.This());
    native->Shutdown();
    return Undefined();
}

v8::Handle<v8::Value> NodeFSEvents::New(const v8::Arguments& args)
{
    HandleScope scope;

    if (args.Length() != 1 || !args[0]->IsString()) {
        return ThrowException(String::New("Bad arguments"));
    }

    String::Utf8Value szPathName(args[0]->ToString());

    NodeFSEvents *nativeobj = new NodeFSEvents(*szPathName);
    nativeobj->Wrap(args.Holder());
    NODE_SET_METHOD(args.Holder(), "stop", NodeFSEvents::Shutdown);
    return args.This();
}

void NodeFSEvents::Shutdown()
{
    // shutdown the thread, if it's running
    if (m_hThread != NULL)
    {
        ::PostQueuedCompletionStatus(m_hIoCPort, 0, 0, NULL);   // tell the thread to quit
        ::WaitForSingleObject(m_hThread, INFINITE);             // wait for the thread to quit
        uv_close((uv_handle_t*) &m_uvaWatcher, NULL);
        m_hThread = NULL;
    }

    // cleanup
    if (m_hIoCPort != NULL)
    {
        ::CloseHandle(m_hIoCPort);
        m_hIoCPort = NULL;
    }
    if (m_hAsyncDir != NULL)
    {
        ::CloseHandle(m_hAsyncDir);
        m_hAsyncDir = NULL;
    }
    if (m_lpBuffer != NULL)
    {
        ::free(m_lpBuffer);
        m_lpBuffer = NULL;
    }
    if (m_pWatchInfo != NULL)
    {
        delete m_pWatchInfo;
        m_pWatchInfo = NULL;
    }
}

DWORD WINAPI NodeFSEvents::Run(LPVOID lpData)
{
    NodeFSEvents *This = (NodeFSEvents*)lpData;
    BOOL bContinue = TRUE;
    while (bContinue && This != NULL)
    {
        // set the watcher
        DWORD dwBytesReturned = (DWORD)0;
        bContinue = ::ReadDirectoryChangesW(This->m_hAsyncDir, This->m_lpBuffer, READ_DIRECTORY_CHANGES_BUFSIZE, TRUE, 
            FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME,
            &dwBytesReturned, &(This->m_Overlapped), NULL);

        if (bContinue)
        {
            // wait for a signal
            DWORD dwNumBytes;
            LPOVERLAPPED lpOverlapped = NULL;
            ULONG_PTR lpCompletionKey = NULL; 
            ::GetQueuedCompletionStatus(This->m_hIoCPort, &dwNumBytes, &lpCompletionKey, &lpOverlapped, INFINITE);
            if (dwNumBytes > 0)
            {
                // process the watched directory change
                PFILE_NOTIFY_INFORMATION pfni = This->m_lpBuffer;
                do
                {
                    TCHAR* lpszFilename = (TCHAR*)malloc(sizeof(TCHAR)*(pfni->FileNameLength + 1));
                    if (lpszFilename != NULL)
                    {
                        memcpy((void*)lpszFilename, (void*)((TCHAR*)pfni->FileName), sizeof(TCHAR) * pfni->FileNameLength);
                        lpszFilename[pfni->FileNameLength / sizeof(TCHAR)] = 0; // null terminate
                        //AfxMessageBox(lpszFilename, MB_OK);
                        free(lpszFilename);

                        pfni = (PFILE_NOTIFY_INFORMATION)(((BYTE*)pfni) + pfni->NextEntryOffset);
                    }
                } while (pfni->NextEntryOffset > 0);
            }
            else
            {
                // signaled from Shutdown() to end this thread
                bContinue = FALSE;
            }
        }
    }

    return TRUE;
}

void NodeFSEvents::Callback(uv_async_t *handle, int status)
{
/*
    NodeFSEvents *This = static_cast<NodeFSEvents*>(handle->data);
    HandleScope scope;
    TryCatch try_catch;
    Local<Value> callback_v = This->handle_->Get(emit_sym);
    Local<Function> callback = Local<Function>::Cast(callback_v);
    p_evt item;
    pthread_mutex_lock(&(This->mutex));

    v8::Handle<v8::Value> args[4];
    args[0] = change_sym;
    This->Ref();
    item = This->first;
    while (item) {
        This->first = item->next;
        if (!try_catch.HasCaught()) {
        args[1] = v8::String::New(item->path ? item->path : "");
        args[2] = v8::Integer::New(item->flags);
        args[3] = v8::Integer::New(item->evtid);
        callback->Call(This->handle_, 4, args);
        }
        free(item);
        item = This->first;
    }
    This->first = NULL;
    This->last = NULL;
    This->Ref();
    pthread_mutex_unlock(&(This->mutex));
    if (try_catch.HasCaught()) try_catch.ReThrow();
*/
}

extern "C" void init(v8::Handle<v8::Object> target) {
    NodeFSEvents::Initialize(target);
}

NODE_MODULE(fswatch_win, init)
